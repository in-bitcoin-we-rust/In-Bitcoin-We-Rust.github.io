# TRRL

+ https://github.com/killercup/trpl-ebook
+ https://github.com/KaiserY/trpl-zh-cn

## 所有权
+ 值有且只有一个所有者
+ 当所有者（变量）离开作用域，这个值将被丢弃。
+ 所有权的转移


### 栈（Stack）与堆（Heap）
+ 栈
    * 后进先出
    * 快
        - 数据存取的位置总是在栈顶而不需要寻找一个位置存放或读取数据
        - 栈中的所有数据都必须占用已知且固定的大小


### 内存与分配
+ GC
    *  记录并清除不再使用的内存
+ rust
    * 内存在拥有它的变量离开作用域后就被自动释放
        - drop/RAII

#### move
浅拷贝（shallow copy）&& drop

Rust 永远也不会自动创建数据的 “深拷贝”

####  clone
deep copy

####  copy
+ 像整型这样的在编译时已知大小的类型被整个存储在 __栈__ 上，所以拷贝其实际的值是快速的
    * 没有深浅拷贝的区别
+ Copy trait
    + 一个旧的变量在将其赋值给其他变量后仍然可用。
    + 规则
        * 任何简单标量值的组合/不需要分配内存或某种形式资源的类型
            - 所有整数类型，比如 u32。
            - 布尔类型，bool，它的值是 true 和 false。
            - 所有浮点数类型，比如 f64。
            - 字符类型，char。
            - 元组，当且仅当其包含的类型也都是 Copy 的时候。
                + 比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是。
    + Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。
        * 如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 注解，将会出现一个编译时错误。


### 引用、借用
允许使用值但不获取其所有权

## 泛型

##  生命周期

## 智能指针

### Box

### Rc

## 并发

### 线程

### 消息传递

### 共享内存

### sync/send

